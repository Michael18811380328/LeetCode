# 啊哈算法

本书基于 C 语言介绍入门的算法，下面是目录

第1章  一大波数正在靠近——排序  
    第1节  最快最简单的排序——桶排序  
    第2节  邻居好说话——冒泡排序  
    第3节  最常用的排序——快速排序  
    第4节  小哼买书

第2章  栈、队列、链表  
    第1节  解密QQ号——队列  
    第2节  解密回文——栈  
    第3节  纸牌游戏——小猫钓鱼  
    第4节  链表  
    第5节  模拟链表

第3章  枚举！很暴力  
    第1节  坑爹的奥数  
    第2节  炸弹人  
    第3节  火柴棍等式  
    第4节  数的全排列

第4章  万能的搜索  
    第1节  不撞南墙不回头——深度优先搜索  
    第2节  解救小哈  
    第3节  层层递进——广度优先搜索  
    第4节  再解炸弹人  
    第5节  宝岛探险  
    第6节  水管工游戏

第5章  图的遍历  
    第1节  深度和广度优先究竟是指啥  
    第2节  城市地图——图的深度优先遍历  
    第3节  最少转机——图的广度优先遍历

第6章  最短路径  
    第1节  只有五行的算法——Floyd-Warshall  
    第2节  Dijkstra算法——单源最短路
    第3节  Bellman-Ford——解决负权边  
    第4节  Bellman-Ford的队列优化  
    第5节  最短路径算法对比分析

第7章  神奇的树  
    第1节  开启“树”之旅  
    第2节  二叉树  
    第3节  堆——神奇的优先队列  
    第4节  擒贼先擒王——并查集

第8章  更多精彩算法  
    第1节  镖局运镖——图的最小生成树  
    第2节  再谈最小生成树  
    第3节  重要城市——图的割点  
    第4节  关键道路——图的割边  
    第5节  我要做月老——二分图最大匹配

第9章  还能更好吗——微软亚洲研究院面试



## 第1章  一大波数正在靠近——排序

    第1节  最快最简单的排序——桶排序：排序的复杂度是 O(m + n) 速度最快，适合范围变化较小的整数数组的排序，出现次数越多更适合这个排序方法。同时排序中可以去重。对于范围变化很大，或者小数，或者对象数组排序不适合。

    第2节  邻居好说话——冒泡排序：最常见的算法，复杂度是 O(n2) 速度最慢，双重循环，适合各种不同的排序情况。如果数据量不大于10000可以考虑这个算法；超过后算法复杂度太高。

    第3节  最常用的排序——快速排序：速度最快，适合最广的算法，复杂度是 O(N * logN)，浏览器内置的排序算法就是基于此的算法

    第4节  小哼买书：书籍的编号一定，书籍需要去重。可以有两个思路实现：可以使用桶排序，这样最快；可以使用快速排序+去重，这样适合更全面。结论：根据具体的问题确定排序的方法，快速排序方法不一定是最佳的方法。

除了上面几个排序方法，还有堆排序，选择排序等其他排序。

## 第2章  栈、队列、链表  

    第1节  解密QQ号——队列：queue，FIFO 先进先出。结构体由一个数组，开始的指针，结束的指针组成。支持增加和减少。减少时，头指针加一；增加时，尾指针增加一，前一个的值是新的值。

    第2节  解密回文——栈：stack 只需要存储一个数组和一个顶点指针。FILO 先进后出，操作顶部指针即可。

    第3节  纸牌游戏——小猫钓鱼：队列和栈的综合应用

    第4节  链表：C语言中通过指针实现链表（需要一部分深入C语言语法）

      指针用途：存储一个地址
      &：取地址符号（获取指针的地址）
      *：三个用途（乘号；声明指针变量（int *q）； 间接访问运算符(printf("%d", *p))）
      malloc: 从内存中申请分配指定字节的大小的内存空间, p = (int *)malloc(sizeof(int))
      malloc 函数返回的是 void * 类型，可以强制转换成其他类型的指针
      指针变量存储的是一个内存地址的首地址，但是这个空间占用多少字节，存储什么数据类型，需要由指针的数据类型标明
      -> 叫做结构体指针运算符（因为指针指向结构体，不能使用 . 访问内部成员，只能使用 -> 访问）

    第5节  模拟链表：使用两个数组模拟链表和指针（数据数组和指针数组实现）

## 第3章  枚举！很暴力

    第1节  坑爹的奥数：使用枚举方法，依次找到满足等式的几个式子

    第2节  炸弹人：二维数组遍历判断最值

    第3节  火柴棍等式：尽量使用数学计算，减少循环的层数

    第4节  数的全排列：使用回溯算法，可以优化全排列（深度优先算法）

## 第4章  万能的搜索

第四章内容较多（60页）是本书的核心章节

    第1节  不撞南墙不回头——深度优先搜索  
    第2节  解救小哈  
    第3节  层层递进——广度优先搜索  
    第4节  再解炸弹人  
    第5节  宝岛探险  
    第6节  水管工游戏

## 第5章  图的遍历

    第1节  深度和广度优先究竟是指啥

    第2节  城市地图——图的深度优先遍历

    第3节  最少转机——图的广度优先遍历

## 第6章  最短路径 (难度较大)

    第1节  只有五行的算法——Floyd-Warshall 
    
    第2节  Dijkstra算法——单源最短路
    
    第3节  Bellman-Ford——解决负权边  
    
    第4节  Bellman-Ford的队列优化  
    
    第5节  最短路径算法对比分析

## 第7章  神奇的树

    第1节  开启“树”之旅

    第2节  二叉树

    第3节  堆——神奇的优先队列
    
    第4节  擒贼先擒王——并查集

## 第8章  更多精彩算法（难度较大）

    第1节  镖局运镖——图的最小生成树

    第2节  再谈最小生成树

    第3节  重要城市——图的割点

    第4节  关键道路——图的割边

    第5节  我要做月老——二分图最大匹配

## 第9章  还能更好吗——微软亚洲研究院面试
