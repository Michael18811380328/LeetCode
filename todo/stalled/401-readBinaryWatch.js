// function readBinaryWatch() {
//   if (num === 0) {
//     return [];
//   }
//   const dict = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
//   let result = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
//   for (let i = 1; i < num; i++) {
//     let tmp = [];
//     for (let j = 0; j < result.length; j++) {
//       let item = result[j];
//       // i
//     }
//   }
// }

// 要求：二进制手表：给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。

// 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。——小时部分如果是1位数，不需要加0
// 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。——分钟部分如果是1位数，需要加0
// 上面两个最后使用函数优化

// 超过表示范围（小时 0-11，分钟 0-59）的数据将会被舍弃，也就是说不会出现 "13:00", "0:61" 等时间。

// 一共有10盏灯，使用回溯算法处理

// 新建一个二维数组，然后随机获取对应的值，然后计算出结果即可
// arr = [[1, 0], [2, 0], [4, 0], [8, 0], [0, 1], [0, 2], [0, 4], [0, 8], [0, 16], [0, 32]];
// 然后求出满足条件的组合
// 然后把数组的结果加起来
// 进行格式化处理
// 即可获取对应的解
// 函数内部实现递归操作


// n = 0
// 返回 ["0:00"]

// 输入: n = 1
// 返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]

// n > 10
// 返回 []

// n === 10
// 返回 [59:59]



function readBinaryWatch(limit) {
  const arr = [[1, 0], [2, 0], [4, 0], [8, 0], [0, 1], [0, 2], [0, 4], [0, 8], [0, 16], [0, 32]];
  // 这里不应该直接传二重数组，应该设置下标[0123456789]这样减少计算复杂性

}


/**
 * 辅助函数：累计时间数组，返回格式化后的字符串
 * @param {*} arr [[4, 0], [8, 0], [0, 1], [0, 2], [0, 4]]
 */
function getSumTime(arr) {
  let hour = 0;
  let minute = 0;
  for (let i = 0; i < arr.length; i++) {
    hour += arr[i][0];
    minute += arr[i][1];
  }
  // format time
  // eslint-disable-next-line prefer-template
  return '' + hour + ':' + minute.toString().padStart('2', '0');
}

export { readBinaryWatch };
