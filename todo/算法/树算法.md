## 红黑树

~~~js
'use strict';

function height(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create(l, v, r) {
  var hl = height(l);
  var hr = height(r);
  return /* Node */ [
    l,
    v,
    r,
    hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  ];
}

function bal(l, v, r) {
  var hl = height(l);
  var hr = height(r);
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height(ll) >= height(lr)) {
        return create(ll, lv, create(lr, v, r));
      } else if (lr) {
        return create(create(ll, lv, lr[0]), lr[1], create(lr[2], v, r));
      } else {
        return /* Empty */ 0;
      }
    } else {
      return /* Empty */ 0;
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height(rr) >= height(rl)) {
        return create(create(l, v, rl), rv, rr);
      } else if (rl) {
        return create(create(l, v, rl[0]), rl[1], create(rl[2], rv, rr));
      } else {
        return /* Empty */ 0;
      }
    } else {
      return /* Empty */ 0;
    }
  } else {
    return /* Node */ [
      l,
      v,
      r,
      hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    ];
  }
}

function compare_int(x, y) {
  if (x > y) {
    return 1;
  } else if (x === y) {
    return 0;
  } else {
    return -1;
  }
}

function add(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = compare_int(x, v);
    if (c) {
      if (c < 0) {
        return bal(add(x, l), v, r);
      } else {
        return bal(l, v, add(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */ [
      /* Empty */
      0,
      x,
      /* Empty */
      0,
      1
    ];
  }
}

function min_elt(_def, _param) {
  while (true) {
    var param = _param;
    var def = _def;
    if (param) {
      var l = param[0];
      if (l) {
        _param = l;
        _def = param[1];
        continue;

      } else {
        return param[1];
      }
    } else {
      return def;
    }
  };
}

function remove_min_elt(l, v, r) {
  if (l) {
    return bal(remove_min_elt(l[0], l[1], l[2]), v, r);
  } else {
    return r;
  }
}

function internal_merge(l, r) {
  if (l) {
    if (r) {
      var rv = r[1];
      return bal(l, min_elt(rv, r), remove_min_elt(r[0], rv, r[2]));
    } else {
      return l;
    }
  } else {
    return r;
  }
}

function remove(x, tree) {
  if (tree) {
    var r = tree[2];
    var v = tree[1];
    var l = tree[0];
    var c = compare_int(x, v);
    if (c) {
      if (c < 0) {
        return bal(remove(x, l), v, r);
      } else {
        return bal(l, v, remove(x, r));
      }
    } else {
      return internal_merge(l, r);
    }
  } else {
    return /* Empty */ 0;
  }
}

function mem(x, _param) {
  while (true) {
    var param = _param;
    if (param) {
      var c = compare_int(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue;

      } else {
        return /* true */ 1;
      }
    } else {
      return /* false */ 0;
    }
  };
}

var v = /* Empty */ 0;

for (var i = 0; i <= 100000; ++i) {
  v = add(i, v);
}

for (var j = 0; j <= 100000; ++j) {
  if (!mem(j, v)) {
    console.log("impossible");
  }

}

for (var k = 0; k <= 100000; ++k) {
  v = remove(k, v);
}

var match = v;

if (match) {
  console.log("impossible");
} else {
  console.log("success");
}

exports.height = height;
exports.create = create;
exports.bal = bal;
exports.compare_int = compare_int;
exports.add = add;
exports.min_elt = min_elt;
exports.remove_min_elt = remove_min_elt;
exports.internal_merge = internal_merge;
exports.remove = remove;
exports.mem = mem;
/*  Not a pure module */
~~~





二分搜索树

~~~js
/**
 * Binary Search Tree(BST or Ordered Binary Tree)
 **/

class Node {
  
  constructor(data, left, right) {
    this.data = data;
    this.left = left;
    this.right = right;
  }

  show() {
    return this.data;
  }
}


class BinarySearchTree {

  constructor() {
    this.root = null;
  }

  insert(data) {
    let n = new Node(data, null, null);
    if (!this.root) {
      return this.root = n;
    }
    let currentNode = this.root;
    let parent = null;
    while (1) {
      parent = currentNode;
      if (data < currentNode.data) {
        currentNode = currentNode.left;
        if (currentNode === null) {
          parent.left = n;
          break;
        }
      } else {
        currentNode = currentNode.right;
        if (currentNode === null) {
          parent.right = n;
          break;
        }
      }
    }
  }

  remove(data) {
    this.root = this.removeNode(this.root, data)
  }

  removeNode(node, data) {
    if (node == null) {
      return null;
    }

    if (data == node.data) {
      // no children node
      if (node.left == null && node.right == null) {
        return null;
      }
      if (node.left == null) {
        return node.right;
      }
      if (node.right == null) {
        return node.left;
      }
      
      let getSmallest = function(node) {
        if(node.left === null && node.right == null) {
          return node;
        }
        if(node.left != null) {
          return node.left;
        }
        if(node.right !== null) {
          return getSmallest(node.right);
        }
        
      }
      let temNode = getSmallest(node.right);
      node.data = temNode.data;
      node.right = this.removeNode(temNode.right,temNode.data);
      return node;

    } else if (data < node.data) {
      node.left = this.removeNode(node.left,data); 
      return node;
    } else {
      node.right = this.removeNode(node.right,data);  
      return node;
    }
  }

  find(data) {
    var current = this.root;
    while (current != null) {
      if (data == current.data) {
        break;
      }
      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right
      }
    }
    return current.data;
  }

  findMax() {
    var current = this.root;
    while (current.right != null) {
      current = current.right;
    }
    return current.data;
  }

  findMin() {
    var current = this.root;
    while (current.left != null) {
      current = current.left;
    }
    return current.data;
  }

  inOrder(node) {
    if (!this.inOrderArr) {
      this.inOrderArr = [];
    }
    if (node !== null) {
      this.inOrder(node.left);
      this.inOrderArr.push(node.data);
      this.inOrder(node.right);
    }
  }

  preOrder(node) {
    if (!this.preOrderArr) {
      this.preOrderArr = [];
    }
    if (node !== null) {
      this.preOrderArr.push(node.data);
      this.preOrder(node.left);
      this.preOrder(node.right);
    }
  }

  postOrder(node) {
    if (!this.postOrderArr) {
      this.postOrderArr = [];
    }
    if (node !== null) {
      this.postOrder(node.left);
      this.postOrder(node.right);
      this.postOrderArr.push(node.data);

    }
  }

}

module.exports = { BinarySearchTree, Node };
~~~

其他

~~~js
class Bing {

  // filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
  // 注意： filter() 不会对空数组进行检测。注意： filter() 不会改变原始数组。
  deleteOddNumber(source) {
    return source.filter((x) => {
      return x % 2 !== 0;
    });
  }

  // delete space or undefined in an array
  // arr = ['A', '', 'B', null, undefined, 'C', ' '];
  deleteSpace(array) {
    return array.filter((x) => {
      return x && x.trim();
    })
  }

  // delete repeat item 
  // arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];
  deleteRepeat (array) {
    return array.filter(function(element, index, arr) {
      return self.indexOf(element) === index;
    });
  }

  setTreeData (source) {
    let cloneData = JSON.parse(JSON.stringify(source));// 对源数据深度克隆
    return cloneData.filter((father) => {// 循环所有项，并添加children属性
      let branchArr = cloneData.filter((child) => {
        father.id == child.parentId
      });   // 返回每一项的子级数组
      branchArr.length > 0 ? father.children = branchArr : '';
      //给父级添加一个children属性，并赋值
      return father.parentId == 0;
      //返回第一层
    });
  }

  // 调用时，字段名以字符串的形式传参，如treeData(source, 'id', 'parentId', 'children')
  treeData (source, id, parentId, children) {
    let cloneData = JSON.parse(JSON.stringify(source))
    return cloneData.filter(father=>{
      let branchArr = cloneData.filter(child => father[id] == child[parentId]);
      branchArr.length > 0 ? father[children] = branchArr : ''
      return father[parentId] == 0;
      // 如果第一层不是parentId=0，请自行修改
    });
  }

}

export Bing
~~~





## 查询类名

~~~js
/**
 * query class name
 **/

function queryClassName(node, name) {
  let walkTheDOM = function(node, func) {
    func(node);
    node = node.firstChild;
    while (node) {
      walkTheDOM(node, func);
      node = node.nextSibling;
    }
  }
  let starts = '(^|[ \n\r\t\f])',
    ends = '([ \n\r\t\f]|$)';
  let regex = new RegExp(starts + name + ends),
    results = [];

  walkTheDOM(node, function (currentNode) {
    if (regex.test(currentNode.className)) {
      results.push(currentNode);
    }
  });

  return results;
}
~~~

