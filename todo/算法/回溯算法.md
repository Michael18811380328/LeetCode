# 回溯算法及简单应用

## 基本原理

回溯算法基于深度优先遍历：把全部的情况描述成一个树，不同的解决方法对应不同的子树。根据DFS，遍历到一个节点后继续向下遍历，如果某个路径无法满足条件，那么返回上一个节点。如果一个子树遍历完成，那么开始遍历另一个子树。

~~~js
function check(node) {
  // 需要一个函数判断当前情况是否满足
}

function DFS(root) {
  // 这里使用递归思路：递归遍历一个子树的全部节点；满足后，返回这个节点
  if (check(root)) {
    // 如果满足一个节点，那么继续判断这个节点下面的节点
    check(root.children)
  } else {
    // 如果不满足一个节点，那么回溯到上一个节点
    break;
  }
}
~~~

## 实际使用

#### 数独问题

一个9*9的数独中，每一行，每一列都是9个数，然后每个小单元格中也是9个数。然后不断回溯。

C++方法

~~~c++
#include<iostream>
using namespace std;
#define LEN 9
int a[LEN][LEN] = {0};

//查询该行里是否有这个值
bool Isvaild(int count) {
  int i = count / 9;
  int j = count % 9;
  // 首先根据一个数，计算余数和商，将一维数据转换成二维数组（i行j列是否满足）
  // 检测行
  for(int iter = 0; iter != j; iter++) {
    if(a[i][iter] == a[i][j]) {
      return 1;
    }
  }
  //检测列
  for(int iter=0; iter!=i; iter++) {
    if(a[iter][j] == a[i][j]){
      return 1;
    }
  }
  //检测九宫   
  for(int p = i/3*3; p < (i/3+1)*3; p++){
    for(int q = j/3*3; q < (j/3+1)*3; q++){
      if(p == i && j == q) {         
        continue;
      }     
      if(a[p][q] == a[i][j]) {
        return 1;
      }
    }
  }
  return 0;
}

void print() {
  cout<<"数度的解集为"<<":"<<endl;
  for(int i=0; i<9; i++) {
    for(int j=0; j<9; j++) {
      cout<<a[i][j]<<" ";
    }
    cout<<endl;
  }
  cout<<endl;
}

void first_chek(int count){
  if(81 == count){
    print();
    return;
  }
  int i = count / 9;   //列
  int j = count % 9;   //行
  if(a[i][j]==0) {
    for(int n=1; n<=9; n++) {
      a[i][j] = n;
      if(!Isvaild(count)){  //这个值不冲突
        first_chek(count+1)
      }
    }      
    a[i][j] = 0;
  }
  else{       
    first_chek(count+1);
  }
}

int main() {
  a[1][2] = 3;
  a[5][3] = 9;
  a[8][8] = 1;
  a[4][4] = 4;
  first_chek(0);
  return 0;
}
~~~

这个思路可以解决复杂情况下，多步骤判断的情况。

#### 8皇后问题

八皇后问题：需要把八个皇后放在国际象棋中，这八个皇后不能互相吃（不能在横线、竖线、斜线上）

JS 方法

~~~js
// 初始化棋盘：每一个节点坐标是i，j，属性index表示是否有位置
// 棋盘总行（列）数 8*8（二维数组）
const n = 8;
// n皇后的解法数
let iCount = 0;
// arr是长度为n*n的一维数组，保存着n*n个对象（li）并有各自的坐标
// 默认index都为-1，表示没有被任何皇后标记过
// arr[ i*n + j ].y = i; arr[ i*n + j ].x = j; 每一个节点的属性
for(var i=0; i<n; i++){
  for(var j=0; j<n; j++){
    arr[i*n + j].x = j;
    arr[i*n + j].y = i;
  }
}

//iQueen从0开始，即皇后0
function setQueen(iQueen){
  if( iQueen == n ){
    iCount++;
    return;
  }
  
  for(var i=0; i<n; i++) {
    if (arr[iQueen * n + i].index == -1 ) {
      arr[iQueen * n + i].index = iQueen;
      var x = arr[iQueen*n + i].x;
      var y = arr[iQueen*n + i].y;
      for(var j=0; j < arr.length; j++) {
        if( arr[j].index == -1 && (arr[j].x == x || arr[j].y == y || arr[j].x - arr[j].y == x - y || arr[j].x + arr[j].y == x + y)  ){
          arr[j].index = iQueen;
        }
      }
      //执行到这里，就会跳到下一层函数中，在执行完下一层的函数后，才会回溯到上一层继续执行for循环（此时的for循环是上一层的for循环），包括后面的所有代码
      //需要注意的是，例如当前函数的iQueen=1，跳到下一层函数 iQueen=2，下一层函数执行完后，回溯到上一层，此时的执行环境已经是上一层的执行环境了，即iQueen是等于1，而不是等于2
      //递归
      setQueen(iQueen + 1);
      //回溯
      for(var j=0; j<arr.length; j++){
        if(arr[j].index == iQueen ){
          arr[j].index = -1;
        }
      }

    }
  }
}
~~~

n皇后问题

~~~js
function nQueens(n) {
	var result = [];
	var k = 0;
	result[k] = 0;
	while (k >= 0) {
    //when k<0; there is no solution for this 'n'
		result[k]++;
		while (result[k] <= n && !place(result, k))
			result[k]++;
    	//find proper position for the current queen
		if (result[k] <= n) {
			if (k == n - 1) break;
      //the last queen is put at a proper position, end
			else {
				k++;
				result[k] = 0;
        //turn to next queen and init her position
			}
		} else {
			result[k] = 0;
      //before feedback, we should reset the position or it will influence next time we find proper position for her
			k--;
		}
	}
	return result;
}

//judge the current position is proper or not
//k is the serial number of the queen
//res is the array of a partial solution
function place(res, k) {
	var abs = Math.abs;
	for (var i = 0; i < k; i++) {
		if (res[i] == res[k] || abs(res[i] - res[k]) == abs(i - k))
			return false;
	}
	return true;
}

var start = Date.now();
var result = nQueens(30);
var end = Date.now();
console.log(result, end - start);
~~~
